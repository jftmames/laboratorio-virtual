<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Informática | Estructuras de Datos (ABB)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Fira+Code:wght@500&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-fira { font-family: 'Fira Code', monospace; }
        .btn-action { transition: background-color 0.2s, transform 0.1s; }
        .btn-action:active { transform: scale(0.95); }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="container mx-auto px-4 py-8">
        <header class="mb-6">
            <a href="informatica.html" class="text-lime-400 hover:text-lime-300 transition duration-300">&larr; Volver a Informática</a>
            <h1 class="text-3xl md:text-4xl font-black text-white mt-2">Visualizador de Estructuras de Datos</h1>
            <h2 class="text-xl text-gray-400">Árbol Binario de Búsqueda (ABB)</h2>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            
            <div class="lg:col-span-3 bg-black rounded-xl border border-gray-700 shadow-2xl p-0 overflow-hidden">
                <canvas id="bstCanvas"></canvas>
            </div>

            <aside class="lg:col-span-1 bg-gray-800 p-4 rounded-xl border border-gray-700 h-fit">
                <h3 class="text-xl font-bold text-lime-300 mb-4">Operaciones</h3>
                
                <div class="mb-4">
                    <label for="nodeValue" class="block mb-2">Valor del Nodo (1-999)</label>
                    <input type="number" id="nodeValue" class="w-full bg-gray-700 text-white p-2 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-lime-400" placeholder="Ej: 42">
                </div>

                <div class="grid grid-cols-2 gap-2 mb-4">
                    <button id="insert-btn" class="btn-action w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg">Insertar</button>
                    <button id="search-btn" class="btn-action w-full bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded-lg">Buscar</button>
                    <button id="delete-btn" class="btn-action w-full bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-lg col-span-2">Eliminar</button>
                </div>

                <div class="border-t border-gray-700 mt-4 pt-4">
                     <button id="random-btn" class="btn-action w-full bg-purple-600 hover:bg-purple-500 text-white font-bold py-2 px-4 rounded-lg mb-2">Poblar Aleatoriamente</button>
                     <button id="reset-btn" class="btn-action w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg">Reiniciar Árbol</button>
                </div>

                <div id="status-panel" class="mt-6 pt-4 border-t border-gray-700">
                    <h4 class="font-bold text-lg text-lime-300 mb-2">Estado</h4>
                    <p id="status-text" class="font-fira text-gray-300 h-24 overflow-y-auto bg-gray-900 p-2 rounded">Listo.</p>
                </div>
            </aside>
        </main>
        
        <section class="mt-8 bg-gray-800 p-6 rounded-xl border border-gray-700">
            <h3 class="text-2xl font-bold text-lime-300 mb-3">¿Qué es un Árbol Binario de Búsqueda?</h3>
            <p class="text-gray-300 leading-relaxed">
                Un ABB es una estructura de datos donde cada "nodo" tiene como máximo dos hijos (izquierdo y derecho). Se rige por una regla simple: para cualquier nodo, todos los valores en su subárbol izquierdo son **menores**, y todos los valores en su subárbol derecho son **mayores**. Esta propiedad permite realizar búsquedas, inserciones y eliminaciones de datos de forma muy rápida (en promedio), ya que en cada paso se descarta la mitad del árbol restante. ¡Observa la animación para ver cómo se recorre el árbol para cada operación!
            </p>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('bstCanvas');
            const ctx = canvas.getContext('2d');

            const controls = {
                valueInput: document.getElementById('nodeValue'),
                insertBtn: document.getElementById('insert-btn'),
                searchBtn: document.getElementById('search-btn'),
                deleteBtn: document.getElementById('delete-btn'),
                randomBtn: document.getElementById('random-btn'),
                resetBtn: document.getElementById('reset-btn'),
            };
            const statusText = document.getElementById('status-text');

            let width, height;
            const NODE_RADIUS = 20;
            const ANIMATION_DELAY = 400;

            class Node {
                constructor(value) {
                    this.value = value;
                    this.left = null;
                    this.right = null;
                    this.x = 0; this.y = 0; // For drawing
                }
            }

            class BinarySearchTree {
                constructor() { this.root = null; }

                insert(value) {
                    const newNode = new Node(value);
                    if (!this.root) {
                        this.root = newNode;
                        return [newNode];
                    }
                    let current = this.root;
                    const path = [];
                    while (true) {
                        path.push(current);
                        if (value === current.value) return null; // No duplicates
                        if (value < current.value) {
                            if (!current.left) {
                                current.left = newNode;
                                path.push(newNode);
                                return path;
                            }
                            current = current.left;
                        } else {
                            if (!current.right) {
                                current.right = newNode;
                                path.push(newNode);
                                return path;
                            }
                            current = current.right;
                        }
                    }
                }

                search(value) {
                    if (!this.root) return { path: [], found: false };
                    let current = this.root;
                    const path = [];
                    while (current) {
                        path.push(current);
                        if (value === current.value) return { path, found: true };
                        if (value < current.value) {
                            current = current.left;
                        } else {
                            current = current.right;
                        }
                    }
                    return { path, found: false };
                }
                
                delete(value) {
                    this.root = this._deleteNode(this.root, value);
                }

                _deleteNode(node, value) {
                    if (node === null) return null;

                    if (value < node.value) {
                        node.left = this._deleteNode(node.left, value);
                        return node;
                    } else if (value > node.value) {
                        node.right = this._deleteNode(node.right, value);
                        return node;
                    } else {
                        if (node.left === null && node.right === null) {
                            return null;
                        }
                        if (node.left === null) return node.right;
                        if (node.right === null) return node.left;
                        
                        let minRight = this._findMin(node.right);
                        node.value = minRight.value;
                        node.right = this._deleteNode(node.right, minRight.value);
                        return node;
                    }
                }

                _findMin(node) {
                    while(node.left) {
                        node = node.left;
                    }
                    return node;
                }
            }
            
            let bst = new BinarySearchTree();

            function setupCanvas() {
                const container = canvas.parentElement;
                width = container.clientWidth;
                height = 500;
                canvas.width = width;
                canvas.height = height;
                draw();
            }

            function drawNode(node, isPath, isFound) {
                if (!node) return;
                ctx.beginPath();
                ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = isFound ? '#a3e635' : (isPath ? '#facc15' : '#1e3a8a');
                ctx.fill();
                ctx.strokeStyle = '#a3e635';
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.value, node.x, node.y);
            }

            function drawEdge(parent, child) {
                ctx.beginPath();
                ctx.moveTo(parent.x, parent.y + NODE_RADIUS);
                ctx.lineTo(child.x, child.y - NODE_RADIUS);
                ctx.strokeStyle = '#4b5563';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            function draw(highlightPath = [], foundNode = null) {
                ctx.clearRect(0, 0, width, height);
                if (!bst.root) return;

                function setPositions(node, x, y, xOffset) {
                    if (!node) return;
                    node.x = x;
                    node.y = y;
                    setPositions(node.left, x - xOffset, y + 70, xOffset / 2);
                    setPositions(node.right, x + xOffset, y + 70, xOffset / 2);
                }
                setPositions(bst.root, width / 2, 50, width / 4);

                function traverseAndDrawEdges(node) {
                    if (!node) return;
                    if (node.left) {
                        drawEdge(node, node.left);
                        traverseAndDrawEdges(node.left);
                    }
                    if (node.right) {
                        drawEdge(node, node.right);
                        traverseAndDrawEdges(node.right);
                    }
                }
                traverseAndDrawEdges(bst.root);

                function traverseAndDrawNodes(node) {
                     if (!node) return;
                     const isPath = highlightPath.includes(node);
                     const isFound = (node === foundNode);
                     drawNode(node, isPath, isFound);
                     traverseAndDrawNodes(node.left);
                     traverseAndDrawNodes(node.right);
                }
                traverseAndDrawNodes(bst.root);
            }

            async function animatePath(path, foundNode = null, message = '') {
                for (let i = 0; i < path.length; i++) {
                    draw(path.slice(0, i + 1), null);
                    await new Promise(r => setTimeout(r, ANIMATION_DELAY));
                }
                if (foundNode) {
                    draw(path, foundNode);
                }
                 statusText.textContent = message;
            }

            function handleInsert() {
                const value = parseInt(controls.valueInput.value);
                if (isNaN(value) || value < 1 || value > 999) {
                    statusText.textContent = "Error: Introduce un número entre 1 y 999.";
                    return;
                }
                const path = bst.insert(value);
                if(path === null){
                    statusText.textContent = `Error: El valor ${value} ya existe.`;
                    return;
                }
                animatePath(path, path[path.length - 1], `Valor ${value} insertado.`);
                controls.valueInput.value = '';
            }
            
            async function handleSearch() {
                const value = parseInt(controls.valueInput.value);
                if (isNaN(value)) {
                    statusText.textContent = "Error: Introduce un número válido.";
                    return;
                }
                const { path, found } = bst.search(value);
                const message = found ? `Valor ${value} encontrado.` : `Valor ${value} no encontrado.`;
                await animatePath(path, found ? path[path.length-1] : null, message);
            }

            async function handleDelete() {
                const value = parseInt(controls.valueInput.value);
                if (isNaN(value)) {
                    statusText.textContent = "Error: Introduce un número válido.";
                    return;
                }
                const { path, found } = bst.search(value);
                await animatePath(path, found ? path[path.length-1] : null, found ? `Eliminando ${value}...` : `${value} no encontrado.`);
                 
                 if(found){
                    setTimeout(() => {
                        bst.delete(value);
                        draw();
                        statusText.textContent = `Valor ${value} eliminado.`;
                    }, ANIMATION_DELAY * 1.5);
                 }
            }

            function handleRandom() {
                bst = new BinarySearchTree(); // Reset
                const nums = new Set();
                while(nums.size < 10) {
                    nums.add(Math.floor(Math.random() * 100) + 1);
                }
                nums.forEach(num => bst.insert(num));
                draw();
                statusText.textContent = "Árbol aleatorio generado.";
            }



            function handleReset() {
                bst = new BinarySearchTree();
                draw();
                statusText.textContent = "Árbol reiniciado.";
            }

            // --- Event Listeners ---
            controls.insertBtn.addEventListener('click', handleInsert);
            controls.searchBtn.addEventListener('click', handleSearch);
            controls.deleteBtn.addEventListener('click', handleDelete);
            controls.randomBtn.addEventListener('click', handleRandom);
            controls.resetBtn.addEventListener('click', handleReset);
            window.addEventListener('resize', setupCanvas);
            
            setupCanvas();
        });
    </script>
</body>
</html>

