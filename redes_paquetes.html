<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Informática | Simulador de Redes de Paquetes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Fira+Code:wght@500&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-fira { font-family: 'Fira Code', monospace; }
        .btn-action { transition: background-color 0.2s, transform 0.1s; }
        .btn-action:active { transform: scale(0.95); }
        .btn-action:disabled { background-color: #4b5563; cursor: not-allowed; }
        select {
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23a3e635' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em 1.5em;
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="container mx-auto px-4 py-8">
        <header class="mb-6">
            <a href="informatica.html" class="text-lime-400 hover:text-lime-300 transition duration-300">&larr; Volver a Informática</a>
            <h1 class="text-3xl md:text-4xl font-black text-white mt-2">Simulador de Redes y Enrutamiento de Paquetes</h1>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            
            <div class="lg:col-span-3 bg-black rounded-xl border border-gray-700 shadow-2xl p-4">
                <canvas id="networkCanvas"></canvas>
            </div>

            <aside class="lg:col-span-1 bg-gray-800 p-4 rounded-xl border border-gray-700 h-fit">
                <h3 class="text-xl font-bold text-lime-300 mb-4">Crear Paquete</h3>
                
                <div class="mb-4">
                    <label for="source-ip" class="block mb-2">IP Origen:</label>
                    <select id="source-ip" class="w-full bg-gray-700 text-white p-2 rounded-lg border border-gray-600"></select>
                </div>

                <div class="mb-4">
                    <label for="dest-ip" class="block mb-2">IP Destino:</label>
                    <select id="dest-ip" class="w-full bg-gray-700 text-white p-2 rounded-lg border border-gray-600"></select>
                </div>
                
                <button id="send-btn" class="btn-action w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg">Enviar Paquete</button>
                
                <div class="border-t border-gray-700 mt-6 pt-4">
                    <h4 class="font-bold text-lg text-lime-300 mb-2">Registro de Eventos</h4>
                    <div id="log-panel" class="font-fira text-sm bg-gray-900 p-2 rounded-lg h-48 overflow-y-auto">
                        <p class="text-gray-500">Selecciona origen/destino y pulsa "Enviar".</p>
                    </div>
                </div>

                <div class="border-t border-gray-700 mt-4 pt-4">
                     <button id="reset-btn" class="btn-action w-full bg-red-600 hover:red-500 text-white font-bold py-2 px-4 rounded-lg">Reiniciar Simulación</button>
                </div>
            </aside>
        </main>
        
        <section class="mt-8 bg-gray-800 p-6 rounded-xl border border-gray-700">
            <h3 class="text-2xl font-bold text-lime-300 mb-3">¿Cómo viajan los datos en una red?</h3>
            <p class="text-gray-300 leading-relaxed">
                Cuando envías datos por internet, se dividen en **paquetes**. Cada paquete contiene la dirección IP de origen y destino.
                <br><br>
                Los **routers** son los carteros de internet. Cada uno tiene una "tabla de enrutamiento" que le dice cuál es el siguiente "salto" para que el paquete llegue a su destino. En esta simulación, la ruta está configurada para ser la más larga posible y así poder observar cada decisión. Sigue el registro de eventos para ver cómo el paquete viaja de router en router.
            </p>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('networkCanvas');
            const ctx = canvas.getContext('2d');

            const controls = {
                sourceSelect: document.getElementById('source-ip'),
                destSelect: document.getElementById('dest-ip'),
                sendBtn: document.getElementById('send-btn'),
                resetBtn: document.getElementById('reset-btn'),
            };
            const logPanel = document.getElementById('log-panel');

            let width, height;
            let nodes = {};
            let packets = [];
            let animationFrameId;

            // Defines the position and properties of each device in the network.
            const networkLayout = {
                'PC-A': { x: 0.1, y: 0.2, type: 'pc', ip: '192.168.1.10' },
                'PC-B': { x: 0.1, y: 0.8, type: 'pc', ip: '192.168.1.20' },
                'Router-1': { x: 0.3, y: 0.5, type: 'router', ip: '192.168.1.1' },
                'Router-2': { x: 0.7, y: 0.3, type: 'router', ip: '10.0.0.1' },
                'Router-3': { x: 0.7, y: 0.7, type: 'router', ip: '10.0.0.2' },
                'PC-C': { x: 0.9, y: 0.5, type: 'pc', ip: '172.16.0.15' },
            };
            
            // Defines the physical connections between devices.
            const connections = [
                ['PC-A', 'Router-1'], ['PC-B', 'Router-1'],
                ['Router-1', 'Router-2'], ['Router-1', 'Router-3'],
                ['Router-2', 'Router-3'], ['Router-2', 'PC-C'], ['Router-3', 'PC-C']
            ];

            // --- ROUTING LOGIC ---
            // These tables determine the path a packet will take.
            // They are intentionally set up to create the longest possible path for demonstration.
            const routingTables = {
                'Router-1': {
                    // To get to PC-C's network (172.16...), the next hop is Router-2.
                    '172.16.': 'Router-2'
                },
                'Router-2': {
                    // To get back to PC-A/B's network, the next hop is Router-1.
                    '192.168.': 'Router-1',
                    // To get to PC-C's network, we take the scenic route via Router-3.
                    '172.16.': 'Router-3'
                },
                'Router-3': {
                    // To get back to PC-A/B's network, the next hop is Router-1.
                    '192.168.': 'Router-1',
                    // From here, PC-C is directly connected.
                    '172.16.': 'PC-C'
                }
            };

            function setupCanvas() {
                const container = canvas.parentElement;
                width = container.clientWidth;
                height = 500;
                canvas.width = width;
                canvas.height = height;

                Object.entries(networkLayout).forEach(([id, data]) => {
                    nodes[id] = { ...data, x: data.x * width, y: data.y * height, id };
                });
            }

            function setupControls() {
                const pcIPs = Object.values(nodes).filter(n => n.type === 'pc').map(n => n.ip);
                controls.sourceSelect.innerHTML = '';
                controls.destSelect.innerHTML = '';
                pcIPs.forEach(ip => {
                    controls.sourceSelect.innerHTML += `<option value="${ip}">${ip}</option>`;
                    controls.destSelect.innerHTML += `<option value="${ip}">${ip}</option>`;
                });
                // Default to the most interesting path: PC-A to PC-C
                controls.sourceSelect.value = '192.168.1.10';
                controls.destSelect.value = '172.16.0.15';
            }

            function addLog(message, color = 'text-gray-300') {
                const p = document.createElement('p');
                p.className = `font-fira ${color}`;
                p.innerHTML = `> ${message}`; // Use innerHTML to allow for bold tags
                logPanel.appendChild(p);
                logPanel.scrollTop = logPanel.scrollHeight;
            }

            function drawNode(node) {
                const size = node.type === 'pc' ? 20 : 25;
                ctx.fillStyle = node.type === 'pc' ? '#3b82f6' : '#22c55e';
                ctx.beginPath();
                if(node.type === 'pc'){
                    ctx.rect(node.x - size/2, node.y - size/2, size, size);
                } else {
                    ctx.arc(node.x, node.y, size/2, 0, 2 * Math.PI);
                }
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = '12px Inter';
                ctx.fillText(node.id, node.x, node.y + size);
                ctx.fillText(node.ip, node.x, node.y + size + 15);
            }

            function drawConnections() {
                ctx.strokeStyle = '#4b5563';
                ctx.lineWidth = 2;
                connections.forEach(([from, to]) => {
                    const nodeFrom = findNodeById(from);
                    const nodeTo = findNodeById(to);
                    ctx.beginPath();
                    ctx.moveTo(nodeFrom.x, nodeFrom.y);
                    ctx.lineTo(nodeTo.x, nodeTo.y);
                    ctx.stroke();
                });
            }
            
            function drawPacket(packet){
                ctx.fillStyle = '#f97316';
                ctx.beginPath();
                ctx.arc(packet.x, packet.y, 8, 0, 2 * Math.PI);
                ctx.fill();
            }

            function draw() {
                ctx.clearRect(0, 0, width, height);
                drawConnections();
                Object.values(nodes).forEach(drawNode);
                packets.forEach(drawPacket);
            }

            function findNodeByIp(ip) {
                return Object.values(nodes).find(n => n.ip === ip);
            }
            
            function findNodeById(id) {
                return Object.values(nodes).find(n => n.id === id);
            }

            function getNextHop(currentNode, destIp) {
                // PCs always send to their default gateway (the router they are connected to).
                if (currentNode.type === 'pc') {
                    const connection = connections.find(c => c.includes(currentNode.id));
                    const gatewayId = connection[0] === currentNode.id ? connection[1] : connection[0];
                    return findNodeById(gatewayId);
                }

                // Routers use their routing tables to decide the next hop.
                if (currentNode.type === 'router') {
                    const table = routingTables[currentNode.id];
                    let nextHopId = null;
                    for (const prefix in table) {
                        if (destIp.startsWith(prefix)) {
                            nextHopId = table[prefix];
                            break;
                        }
                    }
                    if (nextHopId) return findNodeById(nextHopId);
                }
                return null; // Packet is dropped if no route is found
            }

            function updatePackets() {
                packets.forEach(p => {
                    if (p.arrived) return;

                    const dx = p.target.x - p.x;
                    const dy = p.target.y - p.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < p.speed) {
                        p.x = p.target.x;
                        p.y = p.target.y;
                        p.currentNode = p.target;

                        if (p.currentNode.ip === p.destIp) {
                            p.arrived = true;
                            addLog(`¡Paquete llegó a <b class="text-lime-400">${p.destIp}</b>!`, 'text-lime-400');
                            controls.sendBtn.disabled = false;
                            return;
                        }

                        if (p.currentNode.type === 'router') {
                            const nextHop = getNextHop(p.currentNode, p.destIp);
                            if (nextHop) {
                                p.target = nextHop;
                                addLog(`Paquete en <b class="text-yellow-400">${p.currentNode.id}</b>. Tabla dice: para ${p.destIp}, ir a <b class="text-yellow-400">${p.target.id}</b>.`);
                            } else {
                                p.arrived = true;
                                addLog(`Paquete descartado en <b class="text-red-500">${p.currentNode.id}</b>: No hay ruta.`, 'text-red-500');
                                controls.sendBtn.disabled = false;
                            }
                        }
                    } else {
                        p.x += (dx / dist) * p.speed;
                        p.y += (dy / dist) * p.speed;
                    }
                });
                packets = packets.filter(p => !p.arrived);
            }

            function gameLoop() {
                updatePackets();
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            
            function handleSend() {
                const sourceIp = controls.sourceSelect.value;
                const destIp = controls.destSelect.value;
                
                if (sourceIp === destIp) {
                    addLog('Error: Origen y destino no pueden ser iguales.', 'text-yellow-400');
                    return;
                }

                handleReset(); // Clear previous packets and logs
                controls.sendBtn.disabled = true;
                
                const startNode = findNodeByIp(sourceIp);
                const firstHop = getNextHop(startNode, destIp);

                if (!firstHop) {
                     addLog('Error: No se puede encontrar la ruta inicial.', 'text-red-500');
                     controls.sendBtn.disabled = false;
                     return;
                }
                addLog(`Paquete creado. Origen: <b class="text-blue-400">${sourceIp}</b>, Destino: <b class="text-blue-400">${destIp}</b>.`);
                addLog(`PC envía el paquete a su router: <b class="text-yellow-400">${firstHop.id}</b>.`);
                
                packets.push({
                    x: startNode.x, y: startNode.y,
                    sourceIp, destIp,
                    currentNode: startNode,
                    target: firstHop,
                    speed: 2.5,
                    arrived: false
                });
            }
            
            function handleReset(){
                packets = [];
                logPanel.innerHTML = '<p class="text-gray-500">Selecciona origen/destino y pulsa "Enviar".</p>';
                controls.sendBtn.disabled = false;
            }

            // --- Init ---
            setupCanvas();
            setupControls();
            
            controls.sendBtn.addEventListener('click', handleSend);
            controls.resetBtn.addEventListener('click', handleReset);
            window.addEventListener('resize', () => {
                cancelAnimationFrame(animationFrameId);
                setupCanvas();
                gameLoop();
            });

            gameLoop();
        });
    </script>
</body>
</html>

