<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matemáticas | Explorador de Fractales</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        canvas { cursor: crosshair; }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #a3e635;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <div class="container mx-auto px-4 py-8">
        <header class="mb-6">
            <a href="matematicas.html" class="text-lime-400 hover:text-lime-300 transition duration-300">&larr; Volver a Matemáticas</a>
            <h1 class="text-3xl md:text-4xl font-black text-white mt-2">Explorador de Fractales: El Conjunto de Mandelbrot</h1>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-4 gap-6">
            
            <div class="lg:col-span-3 bg-black rounded-xl border border-gray-700 shadow-2xl p-0 overflow-hidden relative">
                <canvas id="fractalCanvas"></canvas>
                <div id="loader" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 hidden">
                    <div class="loader"></div>
                </div>
            </div>

            <aside class="lg:col-span-1 bg-gray-800 p-4 rounded-xl border border-gray-700 h-fit">
                <h3 class="text-xl font-bold text-lime-300 mb-4">Controles</h3>
                <div class="space-y-4">
                    <div>
                        <label for="iterations" class="block mb-2 text-sm font-medium">Iteraciones (detalle): <span id="iterations-label">100</span></label>
                        <input id="iterations" type="range" min="50" max="500" value="100" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <button id="redraw-btn" class="w-full bg-lime-600 hover:bg-lime-500 text-white font-bold py-2 px-4 rounded-lg">Redibujar</button>
                    <button id="reset-btn" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-4 rounded-lg">Reiniciar Vista</button>
                </div>
                <div class="border-t border-gray-700 mt-6 pt-4 text-gray-400">
                    <h4 class="font-bold text-lime-300 text-lg mb-2">Instrucciones</h4>
                    <ul class="list-disc list-inside space-y-2 text-sm">
                        <li><strong>Zoom:</strong> Usa la rueda del ratón sobre el fractal.</li>
                        <li><strong>Panorámica:</strong> Haz clic y arrastra para mover la vista.</li>
                        <li>Aumenta las <strong>iteraciones</strong> para más detalle (tarda más en calcular) y pulsa "Redibujar".</li>
                    </ul>
                </div>
            </aside>
        </main>
        
        <section class="mt-8 bg-gray-800 p-6 rounded-xl border border-gray-700">
            <h3 class="text-2xl font-bold text-lime-300 mb-3">¿Qué es el Conjunto de Mandelbrot?</h3>
            <p class="text-gray-300 leading-relaxed">
                El Conjunto de Mandelbrot es un famoso conjunto de números complejos que, al ser graficado, crea una figura fractal infinitamente detallada. Para cada punto del plano, se aplica repetidamente una sencilla fórmula matemática. Si el resultado de esa fórmula se mantiene "pequeño" (no escapa al infinito) sin importar cuántas veces se repita, el punto pertenece al conjunto y se colorea de negro. Si escapa, se le asigna un color basado en qué tan rápido lo hace. Esto crea los patrones coloridos que ves. Es un ejemplo perfecto de cómo reglas muy simples pueden generar una complejidad extraordinaria.
            </p>
        </section>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('fractalCanvas');
            const ctx = canvas.getContext('2d');
            const loader = document.getElementById('loader');
            const iterationsInput = document.getElementById('iterations');
            const iterationsLabel = document.getElementById('iterations-label');
            const redrawBtn = document.getElementById('redraw-btn');
            const resetBtn = document.getElementById('reset-btn');

            let width, height;
            let maxIterations = 100;

            let panX = -0.5, panY = 0;
            let zoom = 1;
            
            let isDragging = false;
            let dragStartX, dragStartY;

            function resizeCanvas() {
                const container = canvas.parentElement;
                width = container.clientWidth;
                height = width; // Keep it square
                canvas.width = width;
                canvas.height = height;
                drawFractal();
            }

            function drawFractal() {
                loader.classList.remove('hidden');
                
                setTimeout(() => {
                    const imageData = ctx.createImageData(width, height);
                    
                    for (let x = 0; x < width; x++) {
                        for (let y = 0; y < height; y++) {
                            
                            const cx = (x - width / 2) * 4 / (width * zoom) + panX;
                            const cy = (y - height / 2) * 4 / (height * zoom) + panY;

                            let zx = 0, zy = 0;
                            let i = 0;

                            while (zx * zx + zy * zy < 4 && i < maxIterations) {
                                let tempX = zx * zx - zy * zy + cx;
                                zy = 2 * zx * zy + cy;
                                zx = tempX;
                                i++;
                            }

                            const pixelIndex = (y * width + x) * 4;
                            if (i === maxIterations) {
                                imageData.data[pixelIndex] = 0;
                                imageData.data[pixelIndex + 1] = 0;
                                imageData.data[pixelIndex + 2] = 0;
                            } else {
                                const hue = (i / maxIterations) * 360;
                                const color = `hsl(${hue}, 100%, 50%)`;
                                const [r, g, b] = hslToRgb(hue / 360, 1, 0.5);
                                imageData.data[pixelIndex] = r;
                                imageData.data[pixelIndex + 1] = g;
                                imageData.data[pixelIndex + 2] = b;
                            }
                            imageData.data[pixelIndex + 3] = 255;
                        }
                    }
                    ctx.putImageData(imageData, 0, 0);
                    loader.classList.add('hidden');
                }, 10); // Allow UI to update
            }
            
            function hslToRgb(h, s, l) {
                let r, g, b;
                if (s == 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }


            // --- Event Listeners ---
            iterationsInput.addEventListener('input', () => {
                iterationsLabel.textContent = iterationsInput.value;
            });

            redrawBtn.addEventListener('click', () => {
                maxIterations = parseInt(iterationsInput.value);
                drawFractal();
            });
            
            resetBtn.addEventListener('click', () => {
                panX = -0.5;
                panY = 0;
                zoom = 1;
                maxIterations = 100;
                iterationsInput.value = 100;
                iterationsLabel.textContent = "100";
                drawFractal();
            });

            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const worldX = (mouseX - width / 2) / (width * zoom) + panX;
                const worldY = (mouseY - height / 2) / (height * zoom) + panY;

                const zoomFactor = e.deltaY < 0 ? 1.5 : 1 / 1.5;
                zoom *= zoomFactor;
                
                panX = worldX - (mouseX - width/2) / (width * zoom);
                panY = worldY - (mouseY - height/2) / (height * zoom);

                drawFractal();
            });
            
            canvas.addEventListener('mousedown', e => {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
            });
            
            canvas.addEventListener('mousemove', e => {
                if(isDragging) {
                    const dx = e.clientX - dragStartX;
                    const dy = e.clientY - dragStartY;
                    
                    panX -= dx * 4 / (width * zoom);
                    panY -= dy * 4 / (height * zoom);
                    
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;
                    
                    drawFractal();
                }
            });
            
            canvas.addEventListener('mouseup', () => { isDragging = false; });
            canvas.addEventListener('mouseleave', () => { isDragging = false; });

            // --- Init ---
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
        });
    </script>
</body>
</html>
